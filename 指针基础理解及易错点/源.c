#include<stdio.h>
int main()
{
	int* p; 
	/*
	p是变量名字，int*表示p变量存放的是int类型变量的地址
	int* p; 表示定义了一个名字叫做p的int*型变量
	（in*型变量就是存放int类型变量地址的类型）
	而不是定义了一个*p类型的变量
	*/
	int i = 3;
	int j = 0;
	//p=i;     error  因为变量i属于int类型的变量 p变量属于int*类型的变量 不能强制转换
	p = &i;
	/*
	&是取地址符 p=&i;表示将i变量的地址赋值给p变量（指针变量）因此p指向i
	不能写成p=i;因为p是int*类型的变量 而i是int类型的变量

	关于指针里的*和&理解    *p就相当于是访问p这个地址里面的所存储的值   
	而&p相当于是访问p这个变量的地址 可以理解成*和p是是一对逆运算
	（前面的*p里的p是指针变量 用int* p;  后面的&p的p是整型变量 用int p;）
	*/
	j = *p;
	/*
	如果一个指针变量指向了某个普通变量，则*指针变量就完全等同于普通变量
	如j=*p；中*p指向了i;就相当于j=i;
	*/
	printf("j=%d\n",j);
	int* q;
	//*q = p;  error  和前面p=i;错误一样 前后变量的类型不一致
	//*q = *p;  error   *q没有赋值   里面存储的是垃圾值（q没有指向一个普通变量） 
	//p = q;    error    q是垃圾值（q没有指向一个普通变量）q赋给了p p也成了垃圾值
	q = &i;
	/*
	q的空间是属于本程序的，所以本程序可以读写q的内容(在程序内q指向了某一个普通变量)
	但是如果q的内部是垃圾值，则本程序不能读写*q的内容（在程序内q为指向某一个普通变量）
	因为此时q所代表的内存单元的控制权限并没有分配给本程序
	所以本程序运行到下一行代码就会出错
	*/
	printf("%d",*q);
	return 0;
}
/*
*p最准确的理解是：*p表示的是以p的内容为地址的变量
*/